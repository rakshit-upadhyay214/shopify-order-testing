{
  "info": {
    "_postman_id": "f0ef0c33-b828-4545-a29e-38cf10942691",
    "name": "Order Sync",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "item": [
    {
      "name": "CreateOrder",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "// Stringify lineItems so they can be safely injected into the GraphQL variables string",
              "const lineItems = pm.iterationData.get('lineItems');",
              "              ",
              "// Helper to check if we have new scenario fields",
              "const isNewScenario = pm.iterationData.has('shippingLines') || pm.iterationData.has('taxesIncluded');",
              "",
              "// Filter lineItems to match OrderCreateLineItemInput structure",
              "const graphqlLineItems = lineItems.map(item => {",
              "    const lineItemInput = {",
              "        variantId: item.variantId,",
              "        quantity: item.quantity",
              "    };",
              "",
              "    // Handle Applied Discounts (Net Price Calculation)",
              "    // OrderCreateLineItemInput does not support appliedDiscounts directly.",
              "    // We simulate it by reducing the price.",
              "    let originalPrice = item.price || 0;",
              "    if (item.appliedDiscounts && item.appliedDiscounts.length > 0) {",
              "        const totalDiscount = item.appliedDiscounts.reduce((sum, discount) => sum + (discount.amount || 0), 0);",
              "        // Ensure price doesn't go negative",
              "        const netPrice = Math.max(0, originalPrice - (totalDiscount / item.quantity)); ",
              "        // Note: validation of amount distribution is simplified here. ",
              "        // Ideally, we'd use a draft order for perfect fidelity, but for orderCreate, we adjust the unit price.",
              "        lineItemInput.priceSet = {",
              "            shopMoney: {",
              "                amount: netPrice.toFixed(2),",
              "                currencyCode: \"USD\"",
              "            }",
              "        };",
              "    } else if (item.price) {",
              "         // Backward compatibility: explicit price if set",
              "         // If not set, Shopify uses variant price. ",
              "         // Check if we need to explicitly set it to override something or just let it be.",
              "         // Previous script didn't set priceSet, relying on Shopify defaults or it was just filtered out.",
              "         // But if we want to support \"price\" override from JSON:",
              "         lineItemInput.priceSet = {",
              "            shopMoney: {",
              "                amount: item.price.toFixed(2),",
              "                currencyCode: \"USD\"",
              "            }",
              "         };",
              "    }",
              "",
              "    // Handle Tax Lines",
              "    if (item.taxLines && item.taxLines.length > 0) {",
              "        lineItemInput.taxLines = item.taxLines.map(tax => ({",
              "            title: tax.title,",
              "            rate: tax.rate,",
              "            priceSet: {",
              "                shopMoney: {",
              "                    amount: tax.price.toFixed(2),",
              "                    currencyCode: \"USD\"",
              "                }",
              "            }",
              "        }));",
              "    }",
              "    ",
              "    return lineItemInput;",
              "});",
              "",
              "pm.variables.set(\"lineItemsString\", JSON.stringify(graphqlLineItems));",
              "",
              "// 1. Get Tax and Discount Data",
              "const taxLines = pm.iterationData.get('taxLines');",
              "const discountCode = pm.iterationData.get('discountCode');",
              "",
              "// Calculate total for Transaction",
              "// Note: This is an approximation. Real total depends on tax settings (included vs excluded) and shipping.",
              "// For sync scenarios, we trust the `totalAmount` if provided, calc includes Taxes and Discounts.",
              "let totalAmount = 0;",
              "let subtotal = 0;",
              "",
              "lineItems.forEach(item => {",
              "    let itemPrice = item.price || 0;",
              "    // If we adjusted price for discount, use that",
              "    if (item.appliedDiscounts) {",
              "         const totalDiscount = item.appliedDiscounts.reduce((sum, d) => sum + (d.amount || 0), 0);",
              "         itemPrice = Math.max(0, itemPrice - (totalDiscount / item.quantity));",
              "    }",
              "    ",
              "    const lineBase = itemPrice * item.quantity;",
              "    subtotal += lineBase;",
              "",
              "    let lineTotal = lineBase;",
              "    ",
              "    // Add line item taxes if present",
              "    if (item.taxLines) {",
              "        item.taxLines.forEach(t => {",
              "            lineTotal += (t.price || 0);",
              "        });",
              "    }",
              "    ",
              "    totalAmount += lineTotal;",
              "});",
              "",
              "// Add Shipping Cost and Taxes to Transaction Amount",
              " const shippingLines = pm.iterationData.get('shippingLines');",
              "let shippingComponent = [];",
              "let shippingCost = 0;",
              "if (shippingLines && shippingLines.length > 0) {",
              "    shippingLines.forEach(shipping => {",
              "        let price = shipping.price || 0;",
              "        shippingCost += price;",
              "        totalAmount += price;",
              "        ",
              "        shippingComponent.push({",
              "            title: shipping.title,",
              "            priceSet: {",
              "                shopMoney: {",
              "                    amount: price.toFixed(2),",
              "                    currencyCode: \"USD\"",
              "                }",
              "            },",
              "            code: shipping.code",
              "        });",
              "    });",
              "}",
              "",
              "// Add Order Level Taxes",
              "if (taxLines && taxLines.length > 0) {",
              "    taxLines.forEach(tax => {",
              "        totalAmount += (tax.price || 0);",
              "    });",
              "}",
              "",
              "// Subtract Order Level Discount",
              "if (discountCode) {",
              "    let discountAmount = 0;",
              "    if (discountCode.type === 'fixed_amount') {",
              "        discountAmount = parseFloat(discountCode.amount || 0);",
              "    } else if (discountCode.type === 'percentage') {",
              "         // Apply percentage to subtotal",
              "        let percentage = parseFloat(discountCode.amount || discountCode.percentage || 0);",
              "        discountAmount = subtotal * (percentage / 100.0);",
              "    } else if (discountCode.type === 'free_shipping') {",
              "        discountAmount = shippingCost;",
              "    }",
              "    ",
              "    totalAmount -= discountAmount;",
              "    totalAmount = Math.max(0, totalAmount);",
              "}",
              "              ",
              "let transactions = [];",
              "if (totalAmount > 0) {",
              "    transactions.push({",
              "        kind: \"SALE\",",
              "        status: \"SUCCESS\",",
              "        amountSet: {",
              "            shopMoney: {",
              "                amount: totalAmount.toFixed(2),",
              "                currencyCode: \"USD\"",
              "            }",
              "        }",
              "    });",
              "}",
              "              ",
              "const orderInput = {",
              "    customer: {",
              "        toAssociate: {",
              "            id: pm.iterationData.get('customerId') || 'gid://shopify/Customer/23056527622512'",
              "        }",
              "    },",
              "    lineItems: graphqlLineItems,",
              "    transactions: transactions,",
              "    shippingAddress: pm.iterationData.get('shippingAddress') || null,",
              "    billingAddress: pm.iterationData.get('billingAddress') || null,",
              "    tags: pm.iterationData.get('tags') || [],",
              "    taxesIncluded: pm.iterationData.get('taxesIncluded') || false",
              "};",
              "",
              "if (shippingComponent.length > 0) {",
              "    orderInput.shippingLines = shippingComponent;",
              "}",
              "",
              "// Handle Order Level Tax Lines (Mapping)",
              "if (taxLines && taxLines.length > 0) {",
              "    orderInput.taxLines = taxLines.map(tax => ({",
              "        title: tax.title,",
              "        rate: tax.rate,",
              "        priceSet: {",
              "            shopMoney: {",
              "                amount: tax.price.toFixed(2),",
              "                currencyCode: \"USD\"",
              "            }",
              "        }",
              "    }));",
              "}",
              "",
              "// Handle Discount Code (Mapping)",
              "if (discountCode) {",
              "    // Map scenario 'discountCode' to OrderCreateDiscountCodeInput",
              "    orderInput.discountCode = {};",
              "    ",
              "    if (discountCode.type === 'percentage') {",
              "        orderInput.discountCode.itemPercentageDiscountCode = {",
              "            code: discountCode.code,",
              "            percentage: parseFloat(discountCode.amount || discountCode.percentage)",
              "        };",
              "    } else if (discountCode.type === 'fixed_amount') {",
              "         orderInput.discountCode.itemFixedDiscountCode = {",
              "            code: discountCode.code,",
              "            amountSet: {",
              "                shopMoney: {",
              "                    amount: parseFloat(discountCode.amount).toFixed(2),",
              "                    currencyCode: \"USD\"",
              "                }",
              "            }",
              "        };",
              "    } else if (discountCode.type === 'free_shipping') {",
              "        orderInput.discountCode.freeShippingDiscountCode = {",
              "            code: discountCode.code",
              "        };",
              "    }",
              "}",
              "",
              "pm.variables.set('orderInput', JSON.stringify(orderInput));"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "const response = pm.response.json();",
              "if (response.data && response.data.orderCreate && response.data.orderCreate.order) {",
              "    const order = response.data.orderCreate.order;",
              "    pm.environment.set(\"orderId\", order.id);",
              "    console.log('[Automation] Order Created:', order.id);",
              "",
              "    // Store line item mapping: variantId -> { lineItemId, price }",
              "    const mapping = {};",
              "    if (order.lineItems && order.lineItems.nodes) {",
              "        order.lineItems.nodes.forEach(item => {",
              "            if (item.variant && item.variant.id) {",
              "                mapping[item.variant.id] = {",
              "                    id: item.id,",
              "                    price: parseFloat(item.originalUnitPriceSet.shopMoney.amount)",
              "                };",
              "            }",
              "        });",
              "    }",
              "    pm.environment.set(\"lineItemMapping\", JSON.stringify(mapping));",
              "} else {",
              "    const errors = response.data && response.data.orderCreate ? response.data.orderCreate.userErrors : response;",
              "    console.error('[Automation] Order Creation Failed:', JSON.stringify(errors));",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "id": "8423fbd0-be76-4a9a-816d-ba9aa1885959",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "X-Shopify-Access-Token",
            "value": "{{accessToken}}",
            "type": "text"
          }
        ],
        "body": {
          "mode": "graphql",
          "graphql": {
            "query": "mutation CreateOrder($order: OrderCreateOrderInput!) {\n  orderCreate(order: $order) { __typename \n    userErrors { __typename \n      field\n      message\n    }\n    order {\n      id\n      name\n      lineItems(first: 10) { __typename \n        nodes { __typename \n          id\n          title\n          quantity\n          variant { __typename \n            id\n          }\n          originalUnitPriceSet { __typename \n            shopMoney { __typename \n              amount\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "variables": "{\n  \"order\": {{orderInput}}\n}"
          }
        },
        "url": {
          "raw": "https://{{shopName}}.myshopify.com/admin/api/{{apiVersion}}/graphql.json",
          "protocol": "https",
          "host": [
            "{{shopName}}",
            "myshopify",
            "com"
          ],
          "path": [
            "admin",
            "api",
            "{{apiVersion}}",
            "graphql.json"
          ]
        }
      }
    },
    {
      "name": "Take Snapshot (Creation)",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "const response = pm.response.json();",
              "if (response.data && response.data.order) {",
              "    console.log('[SNAPSHOT][POST-CREATION][' + pm.iterationData.get('scenarioName') + ']', JSON.stringify(response.data.order, null, 2));",
              "    ",
              "    // Capture parent transaction ID for refund",
              "    if (response.data.order.transactions) {",
              "        const transactions = response.data.order.transactions;",
              "        let saleTx = null;",
              "        if (Array.isArray(transactions)) {",
              "            saleTx = transactions.find(node => node.kind === 'SALE' || node.kind === 'CAPTURE');",
              "        }",
              "        if (saleTx) {",
              "            pm.environment.set('parentTransactionId', saleTx.id);",
              "            console.log('[Automation] Captured Parent Transaction ID: ' + saleTx.id);",
              "        }",
              "    }",
              "} else {",
              "    console.warn('[Snapshot] Could not retrieve order for snapshot. OrderID: ' + pm.environment.get('orderId'));",
              "    console.warn('[Snapshot] Full Response:', JSON.stringify(response));",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "id": "f1950294-abe6-47cb-8ea8-b0723e292628",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "X-Shopify-Access-Token",
            "value": "{{accessToken}}"
          }
        ],
        "body": {
          "mode": "graphql",
          "graphql": {
            "query": "query GetFullOrderSnapshot($id: ID!) {\n  order(id: $id) {\n    __typename\n    id\n    name\n    displayFinancialStatus\n    displayFulfillmentStatus\n    createdAt\n    \n    currentTotalPriceSet {\n      shopMoney {\n        amount\n        currencyCode\n      }\n    }\n\n    lineItems(first: 50) {\n      nodes {\n        __typename\n        id\n        title\n        variant {\n          id\n          title\n        }\n        quantity\n        currentQuantity\n        unfulfilledQuantity\n        originalUnitPriceSet {\n          shopMoney {\n            amount\n            currencyCode\n          }\n        }\n      }\n    }\n\n    fulfillments(first: 10) {\n      __typename\n      id\n      status\n      createdAt\n      fulfillmentLineItems(first: 50) {\n        nodes {\n          __typename\n          id\n          quantity\n          lineItem {\n            id\n          }\n        }\n      }\n    }\n\n    refunds(first: 10) {\n      __typename\n      id\n      createdAt\n      totalRefundedSet {\n        shopMoney {\n          amount\n          currencyCode\n        }\n      }\n      \n      refundLineItems(first: 20) {\n        edges {\n          node {\n            __typename\n            id\n            quantity\n            restockType\n            priceSet {\n              shopMoney {\n                amount\n              }\n            }\n            lineItem {\n              id\n              quantity\n              variant {\n                id\n              }\n            }\n          }\n        }\n      }\n    }\n\n    transactions {\n      __typename\n      id\n      kind\n      status\n      amountSet {\n        shopMoney {\n          amount\n          currencyCode\n        }\n      }\n    }\n  }\n}",
            "variables": {
              "id": "{{orderId}}"
            }
          }
        },
        "url": {
          "raw": "https://{{shopName}}.myshopify.com/admin/api/{{apiVersion}}/graphql.json",
          "protocol": "https",
          "host": [
            "{{shopName}}",
            "myshopify",
            "com"
          ],
          "path": [
            "admin",
            "api",
            "{{apiVersion}}",
            "graphql.json"
          ]
        }
      }
    },
    {
      "name": "GetFulfillmentOrders",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "const response = pm.response.json();",
              "if (response.errors || !response.data || !response.data.order || !response.data.order.fulfillmentOrders) {",
              "    console.error('[Automation] Failed to fetch fulfillment orders:', JSON.stringify(response.errors || response));",
              "    return;",
              "}",
              "",
              "const fulfillmentOrders = response.data.order.fulfillmentOrders.nodes;",
              "if (fulfillmentOrders.length === 0) {",
              "    console.error('[Automation] No fulfillment orders found');",
              "    return;",
              "}",
              "",
              "const fo = fulfillmentOrders[0];",
              "pm.environment.set(\"fulfillmentOrderId\", fo.id);",
              "if (fo.assignedLocation && fo.assignedLocation.location) {",
              "    pm.environment.set(\"locationId\", fo.assignedLocation.location.id);",
              "    console.log('[Automation] Captured Location ID:', fo.assignedLocation.location.id);",
              "}",
              "",
              "const scenarioFulfillmentQuantities = pm.iterationData.get('fulfillmentItems') || [];",
              "",
              "const mappedLineItems = [];",
              "const fulfillmentLineItemMapping = {};",
              "",
              "fo.lineItems.nodes.forEach(foLineItem => {",
              "    const variantId = foLineItem.lineItem ? foLineItem.lineItem.variant.id : null;",
              "    if (variantId) {",
              "        fulfillmentLineItemMapping[variantId] = foLineItem.id;",
              "        ",
              "        // Find matching fulfillment item by variantId",
              "        const targetItem = scenarioFulfillmentQuantities.find(fi => fi.variantId === variantId);",
              "        if (targetItem) {",
              "             const qtyToFulfill = targetItem.quantity;",
              "             if (qtyToFulfill > 0) {",
              "                mappedLineItems.push({",
              "                    id: foLineItem.id,",
              "                    quantity: qtyToFulfill",
              "                });",
              "             }",
              "        }",
              "    }",
              "});",
              "",
              "pm.environment.set(\"fulfillmentLineItems\", JSON.stringify(mappedLineItems));",
              "pm.environment.set(\"fulfillmentLineItemMapping\", JSON.stringify(fulfillmentLineItemMapping));",
              "console.log('[Automation] Mapped Fulfillment Items:', JSON.stringify(mappedLineItems));",
              "console.log('[Automation] Captured Fulfillment Line Item Mapping:', JSON.stringify(fulfillmentLineItemMapping));"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "id": "c5102722-8b33-47a5-ba81-ad0bf1bb3796",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "X-Shopify-Access-Token",
            "value": "{{accessToken}}"
          }
        ],
        "body": {
          "mode": "graphql",
          "graphql": {
            "query": "query GetFO($id: ID!) {\n  order(id: $id) { __typename \n    fulfillmentOrders(first: 5) { __typename \n      nodes { __typename \n        id\n        status\n        assignedLocation {\n          location {\n            id\n            name\n          }\n        }\n        lineItems(first: 50) { __typename \n          nodes { __typename \n            id\n            lineItem {\n              variant { __typename \n                id\n              }\n            }\n          }\n        }\n      }\n    }\n    lineItems(first: 10) {\n      nodes {\n        title\n        variant {\n          id\n          title\n          inventoryItem {\n            id\n            tracked\n            requiresShipping\n          }\n        }\n      }\n    }\n  }\n}",
            "variables": "{\n  \"id\": \"{{orderId}}\"\n}"
          }
        },
        "url": {
          "raw": "https://{{shopName}}.myshopify.com/admin/api/{{apiVersion}}/graphql.json",
          "protocol": "https",
          "host": [
            "{{shopName}}",
            "myshopify",
            "com"
          ],
          "path": [
            "admin",
            "api",
            "{{apiVersion}}",
            "graphql.json"
          ]
        }
      }
    },
    {
      "name": "CreateFulfillment",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "const itemsStr = pm.environment.get(\"fulfillmentLineItems\");",
              "const items = itemsStr ? JSON.parse(itemsStr) : [];",
              "if (items.length === 0) {",
              "    console.log('[Automation] Skipping fulfillment: No items to fulfill');",
              "    pm.execution.skipRequest();",
              "}"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "const response = pm.response.json();",
              "if (response.data && response.data.fulfillmentCreate && response.data.fulfillmentCreate.fulfillment) {",
              "    console.log('[Automation] Fulfillment Created Successfully');",
              "    const fulfillment = response.data.fulfillmentCreate.fulfillment;",
              "    const fliMapping = {};",
              "    if (fulfillment.fulfillmentLineItems && fulfillment.fulfillmentLineItems.nodes) {",
              "        fulfillment.fulfillmentLineItems.nodes.forEach(node => {",
              "            if (node.lineItem && node.lineItem.variant) {",
              "                fliMapping[node.lineItem.variant.id] = node.id;",
              "            }",
              "        });",
              "        pm.environment.set('fulfillmentLineItemMapping', JSON.stringify(fliMapping));",
              "        console.log('[Automation] Captured FulfillmentLineItem IDs:', JSON.stringify(fliMapping));",
              "    }",
              "} else {",
              "    const errors = response.data && response.data.fulfillmentCreate ? response.data.fulfillmentCreate.userErrors : response;",
              "    console.error('[Automation] Fulfillment Failed:', JSON.stringify(errors));",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "id": "89ccbd30-9079-4c51-9483-4fbf9f09bc4d",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "X-Shopify-Access-Token",
            "value": "{{accessToken}}",
            "type": "text"
          }
        ],
        "body": {
          "mode": "graphql",
          "graphql": {
            "query": "mutation fulfillmentCreate($fulfillment: FulfillmentInput!) { __typename \n  fulfillmentCreate(fulfillment: $fulfillment) { __typename \n    fulfillment { __typename \n      id\n      status\n      fulfillmentLineItems(first: 50) { __typename \n        nodes { __typename \n          id\n          lineItem { __typename \n            variant { __typename \n              id\n            }\n          }\n        }\n      }\n    }\n    userErrors { __typename \n      field\n      message\n    }\n  }\n}",
            "variables": "{\n  \"fulfillment\": {\n    \"lineItemsByFulfillmentOrder\": [\n      {\n        \"fulfillmentOrderId\": \"{{fulfillmentOrderId}}\",\n        \"fulfillmentOrderLineItems\": {{fulfillmentLineItems}}\n      }\n    ]\n  }\n}"
          }
        },
        "url": {
          "raw": "https://{{shopName}}.myshopify.com/admin/api/{{apiVersion}}/graphql.json",
          "protocol": "https",
          "host": [
            "{{shopName}}",
            "myshopify",
            "com"
          ],
          "path": [
            "admin",
            "api",
            "{{apiVersion}}",
            "graphql.json"
          ]
        }
      }
    },
    {
      "name": "Take Snapshot (Fulfillment)",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "const response = pm.response.json();",
              "if (response.data && response.data.order) {",
              "    console.log('[SNAPSHOT][FULFILLMENT][' + pm.iterationData.get('scenarioName') + ']', JSON.stringify(response.data.order, null, 2));",
              "} else {",
              "    console.warn('[Snapshot] Could not retrieve order for snapshot');",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "id": "2e930cd7-27b6-47ca-b646-9bfbfce61911",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "X-Shopify-Access-Token",
            "value": "{{accessToken}}"
          }
        ],
        "body": {
          "mode": "graphql",
          "graphql": {
            "query": "query GetFullOrderSnapshot($id: ID!) {\n  order(id: $id) {\n    __typename\n    id\n    name\n    displayFinancialStatus\n    displayFulfillmentStatus\n    createdAt\n    \n    currentTotalPriceSet {\n      shopMoney {\n        amount\n        currencyCode\n      }\n    }\n\n    lineItems(first: 50) {\n      nodes {\n        __typename\n        id\n        title\n        variant {\n          id\n          title\n        }\n        quantity\n        currentQuantity\n        unfulfilledQuantity\n        originalUnitPriceSet {\n          shopMoney {\n            amount\n            currencyCode\n          }\n        }\n      }\n    }\n\n    fulfillments(first: 10) {\n      __typename\n      id\n      status\n      createdAt\n      fulfillmentLineItems(first: 50) {\n        nodes {\n          __typename\n          id\n          quantity\n          lineItem {\n            id\n          }\n        }\n      }\n    }\n\n    refunds(first: 10) {\n      __typename\n      id\n      createdAt\n      totalRefundedSet {\n        shopMoney {\n          amount\n          currencyCode\n        }\n      }\n      \n      refundLineItems(first: 20) {\n        edges {\n          node {\n            __typename\n            id\n            quantity\n            restockType\n            priceSet {\n              shopMoney {\n                amount\n              }\n            }\n            lineItem {\n              id\n              quantity\n              variant {\n                id\n              }\n            }\n          }\n        }\n      }\n    }\n\n    transactions {\n      __typename\n      id\n      kind\n      status\n      amountSet {\n        shopMoney {\n          amount\n          currencyCode\n        }\n      }\n    }\n  }\n}",
            "variables": {
              "id": "{{orderId}}"
            }
          }
        },
        "url": {
          "raw": "https://{{shopName}}.myshopify.com/admin/api/{{apiVersion}}/graphql.json",
          "protocol": "https",
          "host": [
            "{{shopName}}",
            "myshopify",
            "com"
          ],
          "path": [
            "admin",
            "api",
            "{{apiVersion}}",
            "graphql.json"
          ]
        }
      }
    },
    {
      "name": "CreateRefund",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "const actionType = pm.iterationData.get('actionType');",
              "if (actionType && actionType !== 'REFUND') {",
              "    pm.execution.skipRequest();",
              "    return;",
              "}",
              "",
              "const refundItems = pm.iterationData.get('refundItems');",
              "const appeasementAmount = pm.iterationData.get('appeasementAmount');",
              "",
              "// Handle appeasement: refund without line items",
              "if (!refundItems || refundItems.length === 0) {",
              "    if (appeasementAmount && appeasementAmount > 0) {",
              "        console.log('[Automation] Processing appeasement refund:', appeasementAmount);",
              "        pm.variables.set('refundInput', JSON.stringify({",
              "            orderId: pm.environment.get('orderId'),",
              "            note: 'Appeasement refund - goodwill gesture',",
              "            notify: true,",
              "            transactions: [{",
              "                orderId: pm.environment.get('orderId'),",
              "                amount: appeasementAmount.toFixed(2),",
              "                gateway: 'cash',",
              "                kind: 'REFUND'",
              "            }]",
              "        }));",
              "        return;",
              "    }",
              "    console.log('[Automation] Skipping refund: No refund items in scenario');",
              "    pm.execution.skipRequest();",
              "    return;",
              "}",
              "",
              "const mappingStr = pm.environment.get('lineItemMapping');",
              "const mapping = mappingStr ? JSON.parse(mappingStr) : {};",
              "",
              "let totalAmount = 0;",
              "const refundLineItems = [];",
              "refundItems.forEach(item => {",
              "    const itemData = mapping[item.variantId];",
              "    if (itemData) {",
              "        refundLineItems.push({",
              "            lineItemId: itemData.id,",
              "            quantity: item.quantity,",
              "            restockType: (['CANCEL', 'RETURN'].includes(item.restockType)) ? item.restockType : 'NO_RESTOCK',",
              "            locationId: item.locationId || pm.environment.get('locationId') || null",
              "        });",
              "        totalAmount += (item.quantity * itemData.price);",
              "    } else {",
              "        console.warn('[Automation] Could not find lineItemId for variant: ' + item.variantId);",
              "    }",
              "});",
              "",
              "if (refundLineItems.length === 0) {",
              "    console.log('[Automation] Skipping refund: No valid line items mapped');",
              "    pm.execution.skipRequest();",
              "    return;",
              "}",
              "",
              "console.log('[Automation] Calculated Refund Amount (Qty * Price):', totalAmount);",
              "",
              "// Get reason from first item or default",
              "const refundReason = refundItems.find(item => item.reason)?.reason || \"Damaged product\";",
              "",
              "const refundTransaction = {",
              "    orderId: pm.environment.get('orderId'),",
              "    amount: totalAmount.toFixed(2),",
              "    gateway: 'cash',",
              "    kind: 'REFUND'",
              "};",
              "",
              "const parentTransactionId = pm.environment.get('parentTransactionId');",
              "if (parentTransactionId) {",
              "    refundTransaction.parentId = parentTransactionId;",
              "} else {",
              "    console.warn('[Automation] Warning: No parentTransactionId found. Refund might fail.');",
              "}",
              "",
              "pm.variables.set('refundInput', JSON.stringify({",
              "    orderId: pm.environment.get('orderId'),",
              "    refundLineItems: refundLineItems,",
              "    note: refundReason,",
              "    notify: true,",
              "    transactions: [refundTransaction]",
              "}));",
              "console.log('[Automation] Refund Input Prepared');"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "const response = pm.response.json();",
              "if (response.data && response.data.refundCreate && response.data.refundCreate.refund) {",
              "    console.log('[Automation] Refund Created:', response.data.refundCreate.refund.id);",
              "    console.log('[Automation] Amount Refunded:', JSON.stringify(response.data.refundCreate.refund.totalRefundedSet));",
              "} else {",
              "    const errors = response.data && response.data.refundCreate ? response.data.refundCreate.userErrors : response;",
              "    console.error('[Automation] Refund Failed:', JSON.stringify(errors));",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "id": "e7b0a1d2-3456-4321-abcd-1234567890ab",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "X-Shopify-Access-Token",
            "value": "{{accessToken}}"
          }
        ],
        "body": {
          "mode": "graphql",
          "graphql": {
            "query": "mutation refundLineItem($input: RefundInput!) {\n  refundCreate(input: $input) { __typename \n    refund {\n      id\n      totalRefundedSet {\n        presentmentMoney { __typename \n          amount\n          currencyCode\n        }\n      }\n    }\n    userErrors { __typename \n      field\n      message\n    }\n  }\n}",
            "variables": "{\n  \"input\": {{refundInput}}\n}"
          }
        },
        "url": {
          "raw": "https://{{shopName}}.myshopify.com/admin/api/{{apiVersion}}/graphql.json",
          "protocol": "https",
          "host": [
            "{{shopName}}",
            "myshopify",
            "com"
          ],
          "path": [
            "admin",
            "api",
            "{{apiVersion}}",
            "graphql.json"
          ]
        }
      }
    },
    {
      "name": "CreateReturn",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "const actionType = pm.iterationData.get('actionType');",
              "if (actionType !== 'RETURN') {",
              "    pm.execution.skipRequest();",
              "    return;",
              "}",
              "",
              "// For now, mirroring refund logic structure, assuming return logic might act similarly to Refund but without transactions or with different mutation",
              "// Using returnCreate mutation if applicable or just logging placeholder",
              "console.log('[Automation] Preparing Return for Order:', pm.environment.get('orderId'));",
              "",
              "const refundItems = pm.iterationData.get('refundItems');",
              "if (!refundItems || refundItems.length === 0) {",
              "    console.log('[Automation] No items to return');",
              "    pm.execution.skipRequest();",
              "    return;",
              "}",
              "",
              "const mappingStr = pm.environment.get('fulfillmentLineItemMapping');",
              "const mapping = mappingStr ? JSON.parse(mappingStr) : {};",
              "const returnLineItems = [];",
              "",
              "refundItems.forEach(item => {",
              "    // Process all items in refundItems for return creation",
              "    // The specific disposition (RESTOCK vs NO_RESTOCK) will be handled in the ProcessReturn step",
              "    if (item.variantId) {",
              "        const fulfillmentLineItemId = mapping[item.variantId];",
              "        if (fulfillmentLineItemId) {",
              "            // Validation for ID type removed to support FulfillmentLineItem IDs",
              "            const returnItem = {",
              "                fulfillmentLineItemId: fulfillmentLineItemId,",
              "                quantity: item.quantity,",
              "                returnReason: item.reason || 'NOT_AS_DESCRIBED'",
              "            };",
              "            if (item.restockingFeePercentage) {",
              "                returnItem.restockingFee = {",
              "                    percentage: item.restockingFeePercentage",
              "                };",
              "            }",
              "            returnLineItems.push(returnItem);",
              "        } else {",
              "             console.warn('[Automation] Could not find fulfillmentLineItemId for variant: ' + item.variantId);",
              "        }",
              "    }",
              "});",
              "",
              "if (returnLineItems.length === 0) {",
              "    console.log('[Automation] Skipping return: No valid refund items found or missing IDs');",
              "    pm.execution.skipRequest();",
              "    return;",
              "}",
              "",
              "const returnInput = {",
              "    orderId: pm.environment.get('orderId'),",
              "    returnLineItems: returnLineItems,",
              "    notifyCustomer: false",
              "};",
              "",
              "pm.variables.set('returnInput', JSON.stringify(returnInput));",
              "console.log('[Automation] Return Input:', JSON.stringify(returnInput));"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "const response = pm.response.json();",
              "if (response.data && response.data.returnCreate && response.data.returnCreate.return) {",
              "    const ret = response.data.returnCreate.return;",
              "    console.log('[Automation] Return Created:', ret.id);",
              "    pm.environment.set('returnId', ret.id);",
              "    ",
              "    // Map FulfillmentLineItemID -> ReturnLineItemID",
              "    const rliMap = {};",
              "    if (ret.returnLineItems && ret.returnLineItems.nodes) {",
              "        ret.returnLineItems.nodes.forEach(node => {",
              "            if (node.fulfillmentLineItem && node.fulfillmentLineItem.id) {",
              "                rliMap[node.fulfillmentLineItem.id] = node.id;",
              "            }",
              "        });",
              "    }",
              "    pm.environment.set('returnLineItemMap', JSON.stringify(rliMap));",
              "    console.log('[Automation] Captured ReturnLineItem Map:', JSON.stringify(rliMap));",
              "",
              "    const rfoLiMap = {};",
              "    if (ret.reverseFulfillmentOrders && ret.reverseFulfillmentOrders.nodes) {",
              "        ret.reverseFulfillmentOrders.nodes.forEach(order => {",
              "            if (order.lineItems && order.lineItems.nodes) {",
              "                order.lineItems.nodes.forEach(item => {",
              "                    if (item.fulfillmentLineItem && item.fulfillmentLineItem.id) {",
              "                         rfoLiMap[item.fulfillmentLineItem.id] = item.id;",
              "                    }",
              "                });",
              "            }",
              "        });",
              "    }",
              "    pm.environment.set('reverseFulfillmentOrderLineItemMap', JSON.stringify(rfoLiMap));",
              "    console.log('[Automation] Captured ReverseFulfillmentOrderLineItem Map:', JSON.stringify(rfoLiMap));",
              "} else {",
              "    const errors = response.data && response.data.returnCreate ? response.data.returnCreate.userErrors : response;",
              "    console.error('[Automation] Return Creation Failed:', JSON.stringify(errors));",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "X-Shopify-Access-Token",
            "value": "{{accessToken}}"
          }
        ],
        "body": {
          "mode": "graphql",
          "graphql": {
            "query": "mutation returnCreate($returnInput: ReturnInput!) {\n  returnCreate(returnInput: $returnInput) { __typename \n    return {\n      id\n      status\n      returnLineItems(first: 50) { \n        nodes { \n          id \n          quantity \n          ... on ReturnLineItem { \n            fulfillmentLineItem { \n              id \n            } \n          } \n        } \n      }\n      reverseFulfillmentOrders(first: 10) {\n        nodes {\n          id\n          lineItems(first: 10) {\n            nodes {\n              id\n              fulfillmentLineItem {\n                id\n              }\n            }\n          }\n        }\n      }\n    }\n    userErrors { __typename \n      field\n      message\n    }\n  }\n}",
            "variables": "{\n  \"returnInput\": {{returnInput}}\n}"
          }
        },
        "url": {
          "raw": "https://{{shopName}}.myshopify.com/admin/api/{{apiVersion}}/graphql.json",
          "protocol": "https",
          "host": [
            "{{shopName}}",
            "myshopify",
            "com"
          ],
          "path": [
            "admin",
            "api",
            "{{apiVersion}}",
            "graphql.json"
          ]
        }
      }
    },
    {
      "name": "ProcessReturn",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "const actionType = pm.iterationData.get('actionType');",
              "if (actionType !== 'RETURN') {",
              "    pm.execution.skipRequest();",
              "    return;",
              "}",
              "",
              "console.log('[Automation] Preparing Return Process...');",
              "",
              "const returnId = pm.environment.get('returnId');",
              "if (!returnId) {",
              "    console.error('[Automation] Missing returnId. Skipping process.');",
              "    pm.execution.skipRequest();",
              "    return;",
              "}",
              "",
              "// Retrieve Maps",
              "// VariantID -> FulfillmentLineItemID",
              "const fliMapStr = pm.environment.get('fulfillmentLineItemMapping');",
              "const variantToFliMap = fliMapStr ? JSON.parse(fliMapStr) : {};",
              "",
              "// FulfillmentLineItemID -> ReturnLineItemID",
              "const rliMapStr = pm.environment.get('returnLineItemMap');",
              "const fliToRliMap = rliMapStr ? JSON.parse(rliMapStr) : {};",
              "",
              "// VariantID -> { price, id } (Original Order Items)",
              "const itemMapStr = pm.environment.get('lineItemMapping');",
              "const variantToItemData = itemMapStr ? JSON.parse(itemMapStr) : {};",
              "",
              "// FulfillmentLineItemID -> ReverseFulfillmentOrderLineItemID",
              "const rfoLiMapStr = pm.environment.get('reverseFulfillmentOrderLineItemMap');",
              "const fliToRfoLiMap = rfoLiMapStr ? JSON.parse(rfoLiMapStr) : {};",
              "",
              "const refundItems = pm.iterationData.get('refundItems') || [];",
              "const returnProcessLineItems = [];",
              "let totalRefundAmount = 0;",
              "",
              "// Find Location",
              "// Using getFO location or implicit",
              "const locationId = pm.environment.get('locationId'); // Captured in GetFulfillmentOrders",
              "",
              "refundItems.forEach(item => {",
              "    const variantId = item.variantId;",
              "    const fliId = variantToFliMap[variantId];",
              "    const rliId = fliToRliMap[fliId];",
              "    const itemData = variantToItemData[variantId];",
              "    ",
              "    if (rliId && itemData) {",
              "                // Calculate Disposition",
              "                // Defaulting to RESTOCKED if type is RETURN, else NOT_RESTOCKED",
              "                let dispositionType = 'NOT_RESTOCKED';",
              "                if (item.restockType === 'RETURN') {",
              "                    dispositionType = 'RESTOCKED';",
              "                } else if (item.restockType === 'NO_RESTOCK') {",
              "                    dispositionType = 'NOT_RESTOCKED';",
              "                }",
              "                ",
              "                const rfoLiId = fliToRfoLiMap[fliId];",
              "                const dispositions = [];",
              "                ",
              "                if (rfoLiId) {",
              "                    const dispositionEntry = {",
              "                        dispositionType: dispositionType,",
              "                        quantity: item.quantity,",
              "                        reverseFulfillmentOrderLineItemId: rfoLiId",
              "                    };",
              "                    ",
              "                    if (dispositionType === 'RESTOCKED' && locationId) {",
              "                        dispositionEntry.locationId = locationId;",
              "                    }",
              "                    ",
              "                    dispositions.push(dispositionEntry);",
              "                } else {",
              "                    console.warn('[Automation] Missing ReverseFulfillmentOrderLineIdentifier for item:', rliId, '. Disposition will be skipped.');",
              "                }",
              "",
              "                // Construct ReturnProcessReturnLineItemInput",
              "                const processInput = {",
              "                    id: rliId,",
              "                    quantity: item.quantity,",
              "                    dispositions: dispositions",
              "                }; ",
              "                ",
              "                returnProcessLineItems.push(processInput);",
              "                ",
              "                // Calculate Refund Amount",
              "                let lineAmount = (itemData.price * item.quantity);",
              "                if (item.restockingFeePercentage) {",
              "                    const fee = lineAmount * (parseFloat(item.restockingFeePercentage) / 100.0);",
              "                    lineAmount -= fee;",
              "                }",
              "                totalRefundAmount += lineAmount;",
              "    } else {",
              "        console.warn('[Automation] Skipping item for process: Missing ReturnLineItem ID or ItemData for variant ' + variantId);",
              "    }",
              "});",
              "",
              "if (returnProcessLineItems.length === 0) {",
              "    console.warn('[Automation] No valid items to process.');",
              "    pm.execution.skipRequest();",
              "    return;",
              "}",
              "",
              "// Handle Shipping Refund",
              "const shippingRefund = pm.iterationData.get('shippingRefund');",
              "let shippingAmountVal = 0;",
              "let refundShippingInput = null;",
              "",
              "if (shippingRefund) {",
              "    shippingAmountVal = parseFloat(shippingRefund.amount || 0);",
              "    refundShippingInput = {",
              "        fullRefund: shippingRefund.fullRefund || false,",
              "        shippingRefundAmount: {",
              "            amount: shippingAmountVal.toFixed(2),",
              "            currencyCode: 'USD'",
              "        }",
              "    };",
              "    console.log('[Automation] Adding Shipping Refund:', shippingAmountVal);",
              "}",
              "",
              "// Determine Final Transaction Amount",
              "let finalRefundAmount = totalRefundAmount + shippingAmountVal;",
              "",
              "// Support explicit override from scenario (for testing partial/custom amounts)",
              "const explicitRefundAmount = pm.iterationData.get('refundAmount');",
              "if (explicitRefundAmount !== undefined && explicitRefundAmount !== null) {",
              "    console.log('[Automation] Overriding calculated refund amount (' + finalRefundAmount + ') with scenario amount:', explicitRefundAmount);",
              "    finalRefundAmount = parseFloat(explicitRefundAmount);",
              "}",
              "",
              "// Construct Financial Transfer",
              "const parentTxId = pm.environment.get('parentTransactionId');",
              "console.log('[Automation] Parent Transaction ID:', parentTxId);",
              "console.log('[Automation] Final Total Refund Amount:', finalRefundAmount);",
              "",
              "let financialTransfer = null;",
              "if (parentTxId && finalRefundAmount > 0) {",
              "    financialTransfer = {",
              "        issueRefund: {",
              "            orderTransactions: [{",
              "                parentId: parentTxId,",
              "                transactionAmount: {",
              "                    amount: finalRefundAmount.toFixed(2),",
              "                    currencyCode: 'USD'",
              "                }",
              "            }]",
              "        }",
              "    };",
              "} else {",
              "    console.warn('[Automation] Skipping Financial Transfer: Missing parentTransactionId or Refund Amount is 0');",
              "}",
              "",
              "const returnProcessInput = {",
              "    returnId: returnId,",
              "    returnLineItems: returnProcessLineItems,",
              "    notifyCustomer: true",
              "};",
              "",
              "if (refundShippingInput) {",
              "    returnProcessInput.refundShipping = refundShippingInput;",
              "}",
              "",
              "if (financialTransfer) {",
              "    returnProcessInput.financialTransfer = financialTransfer;",
              "}",
              "",
              "pm.variables.set('processInput', JSON.stringify(returnProcessInput));",
              "console.log('[Automation] ReturnProcess Input:', JSON.stringify(returnProcessInput));"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "const response = pm.response.json();",
              "if (response.data && response.data.returnProcess && response.data.returnProcess.return) {",
              "    console.log('[Automation] Return Processed Successfully. Return ID:', response.data.returnProcess.return.id);",
              "    console.log('[Automation] Return Status:', response.data.returnProcess.return.status);",
              "} else {",
              "    const errors = response.data && response.data.returnProcess ? response.data.returnProcess.userErrors : response;",
              "    console.error('[Automation] Return Process Failed:', JSON.stringify(errors));",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "X-Shopify-Access-Token",
            "value": "{{accessToken}}"
          }
        ],
        "body": {
          "mode": "graphql",
          "graphql": {
            "query": "mutation ReturnProcessMutation($input: ReturnProcessInput!) {\n  returnProcess(input: $input) {\n    return {\n      id\n      status\n    }\n    userErrors {\n      field\n      message\n      code\n    }\n  }\n}",
            "variables": "{\n  \"input\": {{processInput}}\n}"
          }
        },
        "url": {
          "raw": "https://{{shopName}}.myshopify.com/admin/api/{{apiVersion}}/graphql.json",
          "protocol": "https",
          "host": [
            "{{shopName}}",
            "myshopify",
            "com"
          ],
          "path": [
            "admin",
            "api",
            "{{apiVersion}}",
            "graphql.json"
          ]
        }
      }
    },
    {
      "name": "Cancel Order",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "const actionType = pm.iterationData.get('actionType');",
              "if (actionType !== 'FULL_CANCEL') {",
              "    pm.execution.skipRequest();",
              "    return;",
              "}",
              "console.log('[Automation] Executing Full Order Cancellation for:', pm.environment.get('orderId'));",
              "",
              "// Map netCancelParams to variables",
              "const params = pm.iterationData.get('netCancelParams') || {};",
              "pm.variables.set('notifyCustomer', params.notifyCustomer !== false);",
              "pm.variables.set('refundMethod', JSON.stringify(params.refundMethod || { originalPaymentMethodsRefund: true }));",
              "pm.variables.set('restock', params.restock !== false);",
              "pm.variables.set('reason', params.reason || 'OTHER');",
              "pm.variables.set('staffNote', params.staffNote || '');"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "const response = pm.response.json();",
              "if (response.data && response.data.orderCancel && (response.data.orderCancel.job || !response.data.orderCancel.orderCancelUserErrors.length)) {",
              "    console.log('[Automation] Full Order Cancel Job Started');",
              "} else {",
              "    const errors = response.data && response.data.orderCancel ? response.data.orderCancel.orderCancelUserErrors : response;",
              "    console.error('[Automation] Full Cancellation Failed:', JSON.stringify(errors));",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "X-Shopify-Access-Token",
            "value": "{{accessToken}}"
          }
        ],
        "body": {
          "mode": "graphql",
          "graphql": {
            "query": "mutation OrderCancel($orderId: ID!, $notifyCustomer: Boolean, $refundMethod: OrderCancelRefundMethodInput!, $restock: Boolean!, $reason: OrderCancelReason!, $staffNote: String) { orderCancel(orderId: $orderId, notifyCustomer: $notifyCustomer, refundMethod: $refundMethod, restock: $restock, reason: $reason, staffNote: $staffNote) { job { id done } orderCancelUserErrors { field message code } } }",
            "variables": "{\n  \"orderId\": \"{{orderId}}\",\n  \"notifyCustomer\": {{notifyCustomer}},\n  \"refundMethod\": {{refundMethod}},\n  \"restock\": {{restock}},\n  \"reason\": \"{{reason}}\",\n  \"staffNote\": \"{{staffNote}}\"\n}"
          }
        },
        "url": {
          "raw": "https://{{shopName}}.myshopify.com/admin/api/{{apiVersion}}/graphql.json",
          "protocol": "https",
          "host": [
            "{{shopName}}",
            "myshopify",
            "com"
          ],
          "path": [
            "admin",
            "api",
            "{{apiVersion}}",
            "graphql.json"
          ]
        }
      }
    },
    {
      "name": "Take Snapshot (Refund / Final)",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "const response = pm.response.json();",
              "if (response.data && response.data.order) {",
              "    console.log('[SNAPSHOT][FINAL][' + pm.iterationData.get('scenarioName') + ']', JSON.stringify(response.data.order, null, 2));",
              "} else {",
              "    console.warn('[Snapshot] Could not retrieve order for snapshot');",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "id": "f2c3d4e5-6789-0abc-def0-1234567890bc",
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "X-Shopify-Access-Token",
            "value": "{{accessToken}}"
          }
        ],
        "body": {
          "mode": "graphql",
          "graphql": {
            "query": "query GetFullOrderSnapshot($id: ID!) {\n  order(id: $id) {\n    __typename\n    id\n    name\n    displayFinancialStatus\n    displayFulfillmentStatus\n    createdAt\n    \n    currentTotalPriceSet {\n      shopMoney {\n        amount\n        currencyCode\n      }\n    }\n\n    lineItems(first: 50) {\n      nodes {\n        __typename\n        id\n        title\n        variant {\n          id\n          title\n        }\n        quantity\n        currentQuantity\n        unfulfilledQuantity\n        originalUnitPriceSet {\n          shopMoney {\n            amount\n            currencyCode\n          }\n        }\n      }\n    }\n\n    fulfillments(first: 10) {\n      __typename\n      id\n      status\n      createdAt\n      fulfillmentLineItems(first: 50) {\n        nodes {\n          __typename\n          id\n          quantity\n          lineItem {\n            id\n          }\n        }\n      }\n    }\n\n    refunds(first: 10) {\n      __typename\n      id\n      createdAt\n      totalRefundedSet {\n        shopMoney {\n          amount\n          currencyCode\n        }\n      }\n      \n      refundLineItems(first: 20) {\n        edges {\n          node {\n            __typename\n            id\n            quantity\n            restockType\n            priceSet {\n              shopMoney {\n                amount\n              }\n            }\n            lineItem {\n              id\n              quantity\n              variant {\n                id\n              }\n            }\n          }\n        }\n      }\n    }\n\n    transactions {\n      __typename\n      id\n      kind\n      status\n      amountSet {\n        shopMoney {\n          amount\n          currencyCode\n        }\n      }\n    }\n  }\n}",
            "variables": {
              "id": "{{orderId}}"
            }
          }
        },
        "url": {
          "raw": "https://{{shopName}}.myshopify.com/admin/api/{{apiVersion}}/graphql.json",
          "protocol": "https",
          "host": [
            "{{shopName}}",
            "myshopify",
            "com"
          ],
          "path": [
            "admin",
            "api",
            "{{apiVersion}}",
            "graphql.json"
          ]
        }
      }
    }
  ]
}